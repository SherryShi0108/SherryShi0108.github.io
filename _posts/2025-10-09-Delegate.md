---
BoxType: Knowledge
CreateTime: 2025-10-09
EditTime: 2025-10-09
ReviewTime: 
ReviewCount: 0
tags:
  - CSharp
title: Delegate
date: 2025-10-9 20:00:00 +0800
categories:
  - Programming Language Fundamentals
  - CSharp
---
# Delegate

| 2W1H | Detail                              |
| ---- | ----------------------------------- |
| Why  | 委托到底为什么会出现在语言中？它的设计意义是什么？解决了哪些编程痛点？ |
| What | 委托是什么？                              |
| How  | 委托是如何工作的？如何使用？                      |

---
### 1-Why

>委托到底为什么会出现在语言中？它的设计意义是什么？解决了哪些编程痛点？

#### 历史背景
+ C语言时代，使用“函数指针”把函数当作参数传递
    + 优点：可以让程序在运行中调用不同逻辑
    + 问题：
        + C函数指针不安全，类型不匹配也能编译，参数签名错误可能崩溃
        + 没有对象上下文
        + 无法和面向对象特性结合；不能绑定对象实例
+ 期望面向对象语言中，出现一种：既能像函数指针那样传递逻辑，又能保持类型安全、支持封装、面向对象 的机制
    + Delegate 出现根本原因

#### 编程痛点

| No  | 编程痛点            | 委托的解决方案               |
| --- | --------------- | --------------------- |
| 1   | 无法将函数当作一等公民传递   | 委托让方法可以像对象一样存储、传递、调用  |
| 2   | 函数指针类型不安全       | 委托在编译期强类型检查           |
| 3   | 回调机制难以封装        | 委托与类成员结合，支持事件、异步回调    |
| 4   | 策略模式实现复杂        | 委托可以直接传递逻辑（函数参数）      |
| 5   | 需要解耦（调用方与执行方独立） | 委托让调用方只依赖“签名”，不关心“实现” |

一等公民（First-class citizen）：编程语言概念
+ 一等公民则可以像普通变量一样，被赋值给变量、作为参数传递、作为返回值返回、存储在数据结构中（如列表、字典）
+ C语言中变量是一等公民，函数不是；不能把函数当作数据传递，只能通过函数指针间接传递
    + 只能执行，不能保存
+ C#的委托机制让函数也成为了一等公民  [代码 4.1]
    + 可以把它放到变量里，随时拿出来执行

#### 核心理解：从“调用”到“通知”

| 意义               | 理解                           |
| ---------------- | ---------------------------- |
| Callback 回调机制    | “我（执行函数）执行，你（调用方）决定我结束后做什么。” |
| Strategy 策略模式的简化 | “算法是可变的，策略由外部决定。”            |
| Event 事件通知机制基础   | “我不知道谁在监听，但我需要广播一个消息。”       |

回调机制
+ 生活类比理解：不关心怎么打印只关心任务完成后能够收到通知
    + “我去开会，你帮我打印文件，打印完告诉我”
    + “打印文件”= 被委托执行的任务，
    + “告诉我结果”= 回调 Callback
+ 程序中类比：某个函数A执行任务，期望任务完成后调用另一个函数B来汇报结果
    + 异步下载，调用异步下载方法，关心下载完成后收到完成通知 [代码 4.2]
+ 委托机制：传参是一个委托类型，意思是“需要一个能接收string参数并返回void的函数”
    + `Action<string> onCompleted`
    + 传入委托后，下载函数不知道你想做什么，只需要知道有一个函数需要在完成后调用即可
    + 谁接收、做什么，均由调用者决定
    + 这就是“回调（Callback）”，也叫“==控制反转（Inversion of Control）==”
+ 意义
    + 模块解耦，下层代码不依赖上层逻辑

策略模式的简化
+ 委托允许“算法行为”在外部定义，极大增强灵活性 [4.3]
+ ==策略注入==

事件通知机制的基础
+ 委托成为事件系统的底层机制，实现发布-订阅解耦
+ UI/消息驱动机制


⭐ 委托的出现，是为了让“函数可以像对象一样传递”，实现类型安全、可组合的回调与通知机制，从而让程序结构更加灵活和解耦。[代码 4.4]

---
### 2-What

>委托是什么？

==委托是一种引用类型，用于存储和调用方法的引用==
+ 定义了方法的签名（参数类型与返回类型），只有与之匹配的方法才能被赋值给该委托变量
+ Delegate = 类型安全的函数指针 + 对象封装能力

| 语法     | 结构                         | 备注      |
| ------ | -------------------------- | ------- |
| 标准语法   | `delegate 返回类型 委托名(参数列表);` | 和类同级    |
| 内置泛型委托 | `Action`                   | 无返回值    |
|        | `Action<T>`                | 带参数无返回值 |
|        | `Func<T, TResult> `        | 带参数有返回值 |
|        | `Predicate<T>`             | 布尔判断函数  |

| 特性    | 说明                              |
| ----- | ------------------------------- |
| 类型安全  | 编译器检查方法签名匹配，防止运行时错误。            |
| 多播支持  | 可一次绑定多个方法，依次调用。                 |
| 引用语义  | 委托是类的实例，可以被存储、传递、组合。            |
| 面向对象  | 委托与类、对象上下文（this）绑定，支持封装。        |
| 函数式特性 | 委托与 Lambda / 匿名方法无缝结合，使逻辑可直接传递。 |

| 概念            | 对应                  |
| ------------- | ------------------- |
| C语言函数指针       | 不安全、裸函数引用           |
| C# 委托         | 安全、有类型检查、支持绑定对象上下文  |
| Lambda / 匿名方法 | 委托的语法糖，便于直接表达逻辑     |
| 事件 event      | 基于委托的封装机制，用于发布/订阅模式 |

⭐ 委托是一种类型安全的函数指针，表示可以引用一个或多个具有特定签名的方法。
⭐ Delegate 是“行为的容器”，可以把一段逻辑包装成一个可传递、可组合的对象


### 3-How

>委托是如何工作的？如何使用？

#### 底层机制

+ 编译器为 delegate 生成一个继承自 System.MulticastDelegate 的类
+ 委托对象内部维护一个调用列表（Invocation List）
+ 每次调用 Invoke() 时，会依次执行列表中的方法
+ 通过 += 或 -= 操作符可以动态注册/注销方法
+ Invoke()、BeginInvoke()、EndInvoke() 提供同步/异步执行机制
+ 后续 async/await、事件（event）都基于该模型演化


#### 设计思想

| 思想        | 含义             | 代码体现                           |
| --------- | -------------- | ------------------------------ |
| 控制反转（IoC） | 下层逻辑回调上层定义的委托  | `DownloadFile(url, callback)`  |
| 解耦        | 调用方与实现方完全独立    | 按钮点击逻辑由外部注册                    |
| 可组合       | 多个行为链式绑定       | `+=` 多播委托                      |
| 类型安全      | 编译器校验方法签名      | `Action<int>` / `Func<string>` |
| 可扩展       | 委托 → 事件 → 异步模型 | `event`, `async/await`         |


#### 常用场景

| 应用场景               | 关键思想       | 示例               |
| ------------------ | ---------- | ---------------- |
| 回调机制（Callback）     | 函数完成后通知调用方 | 下载完成、任务结束通知      |
| 策略模式（Strategy）     | 把算法注入函数参数  | 排序比较器、过滤器        |
| 事件驱动（Event-driven） | 广播通知给多个订阅者 | 按钮点击、状态变化        |
| 函数式编程（Functional）  | 把逻辑当作数据传递  | LINQ、Pipeline 逻辑 |

### 4-Example

#### 4.1
+ C# 引入了 delegate，让函数也可以被 存到变量里、当作参数传递、当作返回值返回

```csharp
void Print(int n) => Console.WriteLine(n);
Action<int> action = Print;   // ✅ 把函数赋值给变量
action(100);                  // ✅ 通过变量调用函数


void Run(Action<int> operation)
{
    operation(5);
}

Run(Print); // ✅ 传入函数


Func<int, int> MakeAdder(int x) // ✅ 返回函数，函数式编程
{
    return y => x + y;
}

var add5 = MakeAdder(5);
Console.WriteLine(add5(10)); // 输出 15
```

#### 4.2

```csharp
void DownloadFile(string url, Action<string> onCompleted)
{
    // 开始下载，省略下载的一系列内容
    Thread.Sleep(1000); // 模拟下载耗时
    onCompleted?.Invoke("下载完成：" + url); // ✅ 下载完成后通知
}

// 调用
DownloadFile("http://example.com", result => Console.WriteLine(result));
```

#### 4.3

```csharp
void Sort<T>(List<T> list, Comparison<T> compare)
{
    list.Sort(compare); // .NET 内部使用的排序方式是快速排序
}

Sort(numbers, (a, b) => a - b);
Sort(strings, (a, b) => a.Length - b.Length);

```

#### 4.4
例子：没有委托的痛苦 vs 有委托的优雅

+ 没有委托

```csharp
class Button
{
    public void Click() { Console.WriteLine("按钮点击"); }
}

class Form
{
    public void Init()
    {
        Button btn = new Button(); // 想在点击后执行某个动作？只能在内部写死！
        btn.Click();
        Console.WriteLine("按钮点击后执行操作");
    }
}
```

+ 有委托

```csharp
class Button
{
    public event Action Clicked;
    public void Click() => Clicked?.Invoke();
}

class Form
{
    public void Init()
    {
        Button btn = new Button();
        btn.Clicked += () => Console.WriteLine("按钮点击后执行操作");
        btn.Click(); // 自动触发
    }
}
```

+ 优势：委托最大的意义所在——解耦
    + Button 不知道 Form
    + Form 决定点击后行为
    + 二者解耦
    + 可复用、可扩展

