---
Title: Event
date: 2025-10-9 22:00:00 +0800
categories:
  - Programming Language Fundamentals
  - CSharp
tags:
  - CSharp
---
# Event

| 2W1H | Detail           |
| ---- | ---------------- |
| Why  | 为什么已经有了委托，还需要事件？ |
| What | 事件是什么？           |
| How  | 事件是如何工作的？如何使用？   |

### 1-Why

>为什么已经有了委托，还需要事件？

+ 委托太自由，容易被误用
    + 纯委托可以被外部随意覆盖（=）、清空（=null）、直接调用
    + 在大型应用中会有严重问题
        + 外部代码误调用事件 → 不符合设计
        + 外部清空委托 → 丢失所有监听者
        + 多人协作项目中，职责边界模糊，难以维护
+ C#设计引入 event
    + 让“谁可以触发事件”与“谁可以订阅事件”严格区分

| No  | 痛点                  | 事件机制的解决方案                     |
| --- | ------------------- | ----------------------------- |
| 1   | 外部可以随意调用委托，破坏封装     | `event` 限制只有定义类内部可以触发（Invoke） |
| 2   | 外部可能清空或覆盖委托         | 外部只能用 `+=` / `-=` 添加或移除订阅     |
| 3   | 需要一对多的消息通知机制        | 事件基于多播委托天然支持“发布-订阅”           |
| 4   | 模块间耦合度高（调用方需知道被调用方） | 事件让模块只依赖“消息类型”，而非具体逻辑         |
| 5   | 异步 UI / 状态变化通知复杂    | 事件提供统一、安全的通知机制                |

⭐ 事件是“被保护的委托”——它建立了**发布者与订阅者的边界**，让通知机制既灵活又安全。


### 2-What

>事件是什么？

==事件是一种特殊的委托成员，用于对象间的通知机制==
+ 是委托的进一步封装，只允许内部触发、外部订阅或退订
+ 事件实现了典型的 发布-订阅 模式（Publish-Subscribe） 
    + 发布者（Publisher）：定义并触发事件的对象
    + 订阅者（Subscriber）：注册回调逻辑的对象
    + 通知机制（Event）：发布者与订阅者之间的桥梁

| 语法     | 结构                                                               |
| ------ | ---------------------------------------------------------------- |
| 标准语法   | `public event 委托 事件名;`                                           |
| 内置委托   | `public event EventHandler SomethingHappened;`                   |
|        | `public delegate void EventHandler(object sender, EventArgs e);` |
| （命名规范） | 事件名称使用动词过去式 `Clicked`, `Completed`, `Changed`                    |

⭐ 事件 = 带访问控制的委托机制，是委托的封装与约束。
+ 它将“可执行的行为”转化为“可订阅的通知”，是 C# 实现发布-订阅、解耦通信、UI驱动与异步通知的核心机制。  
+ 如果说委托让函数可传递，事件则让“行为的发生”可被观察。


### 3-How

>事件是如何工作的？

#### 底层机制

- 编译器为事件生成一个私有的委托字段
- 自动生成 `add` / `remove` 方法，用于 `+=` / `-=`
- 外部代码不能直接访问底层委托
- 内部通过 `?.Invoke()` 触发所有订阅方法
- 多播委托保证所有监听者都能接收到事件

#### 实际应用场景

+ 例子
    + [5.1 基础订阅事件]
    + [5.2 使用自定义参数事件]
    + [5.3 高级用法：自定义 add/remove]

| 场景     | 意义       | 示例          |
| ------ | -------- | ----------- |
| UI控件   | 用户操作通知   | 按钮点击、文本变化   |
| 系统消息   | 广播状态变更   | 网络连接变化、设备插拔 |
| 模块通信   | 低耦合模块间交互 | 数据更新、任务完成   |
| 异步流程回调 | 通知任务完成   | 下载完成、任务超时   |
| 自定义框架  | 事件驱动架构   | 发布-订阅、插件机制  |


### 4-delegate vs event

+ 事件是带访问控制的委托机制，是委托的封装与约束
+ 事件是委托的进一步封装，只允许内部触发、外部订阅或退订

| 特性   | 委托                       | 事件                             |
| ---- | ------------------------ | ------------------------------ |
| 定义方式 | `public DelegateType D;` | `public event DelegateType D;` |
| 外部访问 | 可赋值、可清空、可调用              | 只能订阅(`+=`)、退订(`-=`)，不能调用       |
| 调用权限 | 任意方                      | 仅定义类内部                         |
| 封装性  | 弱（公开可变）                  | 强（保护封装）                        |
| 典型场景 | 策略、回调                    | 通知、订阅、UI、消息驱动                  |

| 层次   | 关键词       | 说明         |
| ---- | --------- | ---------- |
| 函数指针 | 低层机制      | C语言时代的函数引用 |
| 委托   | 类型安全的函数引用 | 行为可传递，可绑定  |
| 事件   | 封装的委托机制   | 行为的安全发布与订阅 |


### 5-Example

#### 5.1 基础订阅事件

```C#
// 1️⃣ 定义事件
public class Button
{
    public event EventHandler Clicked;

    public void Click()
    {
        Console.WriteLine("按钮被点击");
        Clicked?.Invoke(this, EventArgs.Empty); // ✅ 通知订阅者
    }
}

// 2️⃣ 订阅与触发
var button = new Button();
button.Clicked += (sender, e) => Console.WriteLine("执行按钮点击逻辑");
button.Click(); // 输出： // 按钮被点击 // 执行按钮点击逻辑
```

#### 5.2 使用自定义参数事件

```C#
// 使用自定义参数事件
public class DownloadEventArgs : EventArgs
{
    public string FileName { get; }
    public DownloadEventArgs(string fileName) => FileName = fileName;
}

public class Downloader
{
    public event EventHandler<DownloadEventArgs> DownloadCompleted;

    public void Start(string file)
    {
        Console.WriteLine($"正在下载 {file}...");
        Thread.Sleep(1000);
        DownloadCompleted?.Invoke(this, new DownloadEventArgs(file));
    }
}

var d = new Downloader();
d.DownloadCompleted += (s, e) => Console.WriteLine($"下载完成：{e.FileName}");
d.Start("report.pdf");
```

#### 5.3 高级用法：自定义 add/remove

+ 正常情况下，事件相当于如下代码

```C#
public event EventHandler MyEvent;

// <上下代码等价>

private EventHandler _MyEvent; // 隐藏字段

public event EventHandler MyEvent
{
    add { _MyEvent += value; }
    remove { _MyEvent -= value; }
}
```

+ 自己控制add/remove，就相当于自己控制了事件的订阅/取消逻辑
    + 默认事件是“语法糖”，自定义事件是“语法糖的底层实现暴露给你”

| 用途       | 示例                  |
| -------- | ------------------- |
| ✅ 日志记录   | 打印谁订阅/取消事件          |
| ✅ 限制订阅数量 | 限制只能有一个订阅者          |
| ✅ 线程安全封装 | 给事件访问加锁（`lock`）     |
| ✅ 延迟注册机制 | 只有第一次订阅时才启动某个后台监控线程 |
| ✅ 多路转发   | 把事件转发给另一个对象的事件      |

| 特性区别 | 默认事件    | 自定义 add/remove 事件  |
| ---- | ------- | ------------------ |
| 底层字段 | 编译器自动生成 | 开发者自定义             |
| 控制权  | 自动管理订阅  | 你可以自定义行为           |
| 常见用途 | 简单发布/订阅 | 日志、懒加载、线程安全、封装底层事件 |
| 可维护性 | 简洁、易懂   | 稍复杂但灵活             |
| 性能   | 编译器优化   | 稍慢一点但可控            |

```C#
// 日志记录
private EventHandler _MyEventHandler;

public event EventHandler MyEvent
{
    add
    {
        Console.WriteLine($"订阅：{value.Method.Name}");
        _MyEventHandler += value;
    }
    remove
    {
        Console.WriteLine($"取消订阅：{value.Method.Name}");
        _MyEventHandler -= value;
    }
}
```

```C#
// 加锁、延迟注册
private EventHandler _onDataChanged;
private int _subscriberCount = 0;

public event EventHandler DataChanged
{
    add
    {
        lock (this)
        {
            _onDataChanged += value;
            _subscriberCount++;
            if (_subscriberCount == 1)
                StartWatchingData(); // 只有第一次订阅才启动后台任务
        }
    }
    remove
    {
        lock (this)
        {
            _onDataChanged -= value;
            _subscriberCount--;
            if (_subscriberCount == 0)
                StopWatchingData(); // 最后一个取消后停止任务
        }
    }
}
```

